-- This document includes the steps taken for the Process Phase and the Analyze Phase.
-- It also contains the SQL script used in almost all of its steps.

-- PROCESS PHASE

-- Tool
-- SQL was selected for its ability to efficiently handle large volumes of data, 
-- providing robust querying and data management capabilities. 
-- This ensures optimal performance and scalability for the analysis.

-- Data Manipulation and Cleaning

-- 1. Data Format Verification:
-- Data was converted to .xlsx format for proper import into SQL.

-- 2. Column and Data Type Verification:
-- Verify column names and data types during the file upload process.
-- We review column names, types, and null allowances across 12 monthly datasets.

-- 3. Data Consolidation:
-- Merge the 12 monthly tables into a single table.

-- SQL Query for data consolidation:
SELECT *
INTO Cyclistic_TripData_2022
FROM divvy_tripdata_202201
UNION ALL
SELECT *
FROM divvy_tripdata_202202
UNION ALL
SELECT *
FROM divvy_tripdata_202203
UNION ALL
SELECT *
FROM divvy_tripdata_202204
UNION ALL
SELECT *
FROM divvy_tripdata_202205
UNION ALL
SELECT *
FROM divvy_tripdata_202206
UNION ALL
SELECT *
FROM divvy_tripdata_202207
UNION ALL
SELECT *
FROM divvy_tripdata_202208
UNION ALL
SELECT *
FROM divvy_tripdata_202209
UNION ALL
SELECT *
FROM divvy_tripdata_202210
UNION ALL
SELECT *
FROM divvy_tripdata_202211
UNION ALL
SELECT *
FROM divvy_tripdata_202212
;

-- Note: This breakdown will be used in the following step.
-- Breakdown of the FROM Clause:
-- cyclistic_bike_share: This is the name of the database that contains your table.
-- dbo: This is the schema within the database.
-- Cyclistic_TripData_2022: This is the specific table created from the consolidated data.

-- 4. Error Detection:
-- Verify categorical values and check for duplicates.

-- SQL Query for Checking categories for rideable_type:
SELECT
	rideable_type
FROM 
	cyclistic_bike_share.dbo.Cyclistic_TripData_2022
GROUP BY
	rideable_type
;

-- SQL Query for checking categories for member_casual column:
SELECT 
	DISTINCT member_casual
FROM 
	cyclistic_bike_share.dbo.Cyclistic_TripData_2022
;

-- SQL Query for checking duplicates in the ride_id column column:
SELECT
	ride_id,
	COUNT(*) as duplicate_count
FROM 
	cyclistic_bike_share.dbo.Cyclistic_TripData_2022
GROUP BY
	ride_id
HAVING
	COUNT(*) > 1
;

-- 5. Null Value Management:
-- Analyze and retain records with essential data, despite null values in station columns.

-- Check for null values in all columns:
SELECT
   SUM(CASE WHEN ride_id IS NULL THEN 1 ELSE 0 END) AS ride_id_null_count,
   SUM(CASE WHEN rideable_type IS NULL THEN 1 ELSE 0 END) AS rideable_type_null_count,
   SUM(CASE WHEN started_at IS NULL THEN 1 ELSE 0 END) AS started_at_null_count,
   SUM(CASE WHEN ended_at IS NULL THEN 1 ELSE 0 END) AS ended_at_null_count,
   SUM(CASE WHEN start_station_name IS NULL THEN 1 ELSE 0 END) AS start_station_name_null_count,
   SUM(CASE WHEN start_station_id IS NULL THEN 1 ELSE 0 END) AS start_station_id_null_count,
   SUM(CASE WHEN end_station_name IS NULL THEN 1 ELSE 0 END) AS end_station_name_null_count,
   SUM(CASE WHEN end_station_id IS NULL THEN 1 ELSE 0 END) AS end_station_id_null_count,
   SUM(CASE WHEN start_lat IS NULL THEN 1 ELSE 0 END) AS start_lat_null_count,
   SUM(CASE WHEN start_lng IS NULL THEN 1 ELSE 0 END) AS start_lng_null_count,
   SUM(CASE WHEN end_lat IS NULL THEN 1 ELSE 0 END) AS end_lat_null_count,
   SUM(CASE WHEN end_lng IS NULL THEN 1 ELSE 0 END) AS end_lng_null_count,
   SUM(CASE WHEN member_casual IS NULL THEN 1 ELSE 0 END) AS member_casual_null_count
FROM 
   cyclistic_bike_share.dbo.Cyclistic_TripData_2022
;

-- 6. New Column Creation:
-- Create new columns for enhanced analysis.

-- Add columns for ride_length_seconds, day_of_week, month, hour_of_day:
ALTER TABLE full_year_data
ADD COLUMN ride_length_seconds INT,
ADD COLUMN day_of_week VARCHAR(10),
ADD COLUMN month VARCHAR(10),
ADD COLUMN hour_of_day INT;

-- Populate these columns:
UPDATE full_year_data
SET ride_length_seconds = TIMESTAMPDIFF(SECOND, started_at, ended_at),
    day_of_week = DAYNAME(started_at),
    month = MONTHNAME(started_at),
    hour_of_day = HOUR(started_at);

-- 7. Data Validation:
-- Remove invalid entries where ride_length_seconds <= 0 or ride exceeds 24 hours.

-- Validate ride length:
DELETE FROM full_year_data 
WHERE ride_length_seconds <= 0 OR ride_length_seconds > 86400;

-- ANALYZE PHASE

-- Tool
-- SQL is used in the analyze phase for its efficiency in handling large datasets.

-- Data Analysis

-- 1. Preferred Types of Bikes for Each Rider Group Over the Year:
SELECT member_casual, rideable_type, COUNT(*) AS bike_count
FROM full_year_data
GROUP BY member_casual, rideable_type;

-- 2. Average Ride Length by Each Rider Group Per Hour:
SELECT member_casual, hour_of_day, AVG(ride_length_seconds) AS avg_ride_length
FROM full_year_data
GROUP BY member_casual, hour_of_day;

-- 3. Average Ride Length by Each Rider Group Per Day:
SELECT member_casual, day_of_week, AVG(ride_length_seconds) AS avg_ride_length
FROM full_year_data
GROUP BY member_casual, day_of_week;

-- 4. Average Ride Length by Each Rider Group Per Month:
SELECT member_casual, month, AVG(ride_length_seconds) AS avg_ride_length
FROM full_year_data
GROUP BY member_casual, month;

-- 5. Annual Average Ride Length by Each Rider Group:
SELECT member_casual, AVG(ride_length_seconds) AS avg_ride_length
FROM full_year_data
GROUP BY member_casual;

-- 6. Total Time Spent by Each Rider Group Per Hour:
SELECT member_casual, hour_of_day, SUM(ride_length_seconds) AS total_time
FROM full_year_data
GROUP BY member_casual, hour_of_day;

-- 7. Total Time Spent by Each Rider Group Per Day:
SELECT member_casual, day_of_week, SUM(ride_length_seconds) AS total_time
FROM full_year_data
GROUP BY member_casual, day_of_week;

-- 8. Total Time Spent by Each Rider Group Per Month:
SELECT member_casual, month, SUM(ride_length_seconds) AS total_time
FROM full_year_data
GROUP BY member_casual, month;

-- 9. Annual Time Spent Percentage by Each Rider Group:
SELECT member_casual, 
       SUM(ride_length_seconds) / (SELECT SUM(ride_length_seconds) FROM full_year_data) * 100 AS percentage_time
FROM full_year_data
GROUP BY member_casual;

-- 10. Total Number of Rides by Each Rider Group Per Hour:
SELECT member_casual, hour_of_day, COUNT(*) AS total_rides
FROM full_year_data
GROUP BY member_casual, hour_of_day;

-- 11. Total Number of Rides by Each Rider Group Per Day:
SELECT member_casual, day_of_week, COUNT(*) AS total_rides
FROM full_year_data
GROUP BY member_casual, day_of_week;

-- 12. Total Number of Rides by Each Rider Group Per Month:
SELECT member_casual, month, COUNT(*) AS total_rides
FROM full_year_data
GROUP BY member_casual, month;

-- 13. Annual Total Rides Percentage by Each Rider Group:
SELECT member_casual, 
       COUNT(*) / (SELECT COUNT(*) FROM full_year_data) * 100 AS percentage_rides
FROM full_year_data
GROUP BY member_casual;

-- 14. Top 5 Routes for Each Group:
-- Top 5 routes for Members:
SELECT start_station_name, end_station_name, COUNT(*) AS route_count
FROM full_year_data
WHERE member_casual = 'member'
GROUP BY start_station_name, end_station_name
ORDER BY route_count DESC
LIMIT 5;

-- Top 5 routes for Casual Riders:
SELECT start_station_name, end_station_name, COUNT(*) AS route_count
FROM full_year_data
WHERE member_casual = 'casual'
GROUP BY start_station_name, end_station_name
ORDER BY route_count DESC
LIMIT 5;
